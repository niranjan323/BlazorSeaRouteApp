using Microsoft.JSInterop;
using PdfSharpCore.Drawing;
using PdfSharpCore.Pdf;
using SeaRouteModel.Models;
using System.Text;

namespace SeaRouteBlazorServerApp.Components.Services;

public class PdfService : IPdfService
{
    private readonly IJSRuntime _jsRuntime;
    private readonly ILogger<PdfService> _logger;

    public PdfService(IJSRuntime jsRuntime, ILogger<PdfService> logger)
    {
        _jsRuntime = jsRuntime;
        _logger = logger;
    }

    public async Task<byte[]> GenerateReportPdfAsync(ReportData reportData)
    {
        try
        {
            _logger.LogInformation("Generating PDF report for: {ReportName}", reportData.ReportName);

            // Create a new PDF document
            var document = new PdfDocument();
            document.Info.Title = reportData.Title;
            document.Info.Author = "ABS Online Reduction Factor Tool";
            document.Info.Subject = reportData.ReportName;
            document.Info.Keywords = "Reduction Factor, ABS, Vessel";

            // Create a new page
            var page = document.AddPage();
            var gfx = XGraphics.FromPdfPage(page);
            var font = new XFont("Arial", 12, XFontStyle.Regular);
            var boldFont = new XFont("Arial", 12, XFontStyle.Bold);
            var titleFont = new XFont("Arial", 18, XFontStyle.Bold);
            var headerFont = new XFont("Arial", 14, XFontStyle.Bold);

            // Define margins and positions
            double margin = 50;
            double y = margin;
            double x = margin;
            double lineHeight = 20;
            double contentWidth = page.Width - (margin * 2);

            // Add title
            gfx.DrawString(reportData.Title, titleFont, XBrushes.Black,
                new XRect(x, y, contentWidth, titleFont.Height), XStringFormats.TopLeft);
            y += titleFont.Height * 2;

            // Add report date
            gfx.DrawString($"Generated on: {DateTime.Now:yyyy-MM-dd HH:mm}", font, XBrushes.Black, x, y);
            y += lineHeight * 1.5;

            // Draw attention section
            gfx.DrawString("Attention:", boldFont, XBrushes.Black, x, y);
            y += lineHeight;
            gfx.DrawString(reportData.AttentionText, font, XBrushes.Black, x + 10, y);
            y += lineHeight * 2;

            // Draw sections
            foreach (var section in reportData.Sections)
            {
                // Check if we need a new page
                if (y + 200 > page.Height - margin) // Arbitrary threshold
                {
                    page = document.AddPage();
                    gfx = XGraphics.FromPdfPage(page);
                    y = margin;
                }

                // Draw section header
                gfx.DrawString(section.Title, headerFont, XBrushes.Black, x, y);
                y += lineHeight * 1.5;

                // Draw section content
                if (section.Type == "table")
                {
                    y = DrawTable(gfx, section.TableData, x, y, contentWidth, font, boldFont);
                }
                else
                {
                    foreach (var textLine in section.Content.Split('\n'))
                    {
                        // Simple text wrapping approximation
                        //var wrappedLines = WrapText(textLine, font, contentWidth);
                        var wrappedLines = WrapText(textLine, font, contentWidth, gfx);
                        foreach (var line in wrappedLines)
                        {
                            gfx.DrawString(line, font, XBrushes.Black, x, y);
                            y += lineHeight;
                        }
                    }
                }

                y += lineHeight; // Space after section
            }

            // Add notes section if available
            if (reportData.Notes?.Count > 0)
            {
                // Check if we need a new page for notes
                if (y + 100 > page.Height - margin)
                {
                    page = document.AddPage();
                    gfx = XGraphics.FromPdfPage(page);
                    y = margin;
                }

                gfx.DrawString("Notes:", headerFont, XBrushes.Black, x, y);
                y += lineHeight * 1.5;

                foreach (var note in reportData.Notes)
                {
                    gfx.DrawString("• " + note, font, XBrushes.Black, x, y);
                    y += lineHeight;
                }
            }

            // Add disclaimer
            var disclaimerText = "This report is generated by the ABS Online Reduction Factor Tool and is subject to the terms and conditions provided by ABS.";

            // Ensure disclaimer is on the last page at the bottom
            double disclaimerY = page.Height - margin - lineHeight;
            gfx.DrawString(disclaimerText, new XFont("Arial", 8, XFontStyle.Italic), XBrushes.Black,
                new XRect(x, disclaimerY, contentWidth, lineHeight), XStringFormats.TopLeft);

            // Save the document to a memory stream
            using (var stream = new MemoryStream())
            {
                document.Save(stream, false);
                return stream.ToArray();
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error generating PDF report");
            throw;
        }
    }

    public async Task DownloadPdfAsync(ReportData reportData, string fileName)
    {
        try
        {
            var pdfBytes = await GenerateReportPdfAsync(reportData);

            // Convert PDF bytes to base64 string for JS interop
            var base64String = Convert.ToBase64String(pdfBytes);

            // Call JavaScript function to trigger download
            await _jsRuntime.InvokeVoidAsync("downloadFileFromBase64", fileName, base64String, "application/pdf");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error downloading PDF");
            throw;
        }
    }

    public async Task PrintPdfAsync(ReportData reportData)
    {
        try
        {
            var pdfBytes = await GenerateReportPdfAsync(reportData);

            // Convert PDF bytes to base64 string for JS interop
            var base64String = Convert.ToBase64String(pdfBytes);

            // Call JavaScript function to trigger printing
            await _jsRuntime.InvokeVoidAsync("printPdfFromBase64", base64String);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error printing PDF");
            throw;
        }
    }

    private double DrawTable(XGraphics gfx, List<ReportTableRow> tableData, double x, double y,
        double width, XFont font, XFont headerFont)
    {
        if (tableData == null || tableData.Count == 0)
            return y;

        // Calculate column widths
        int colCount = tableData[0].Cells.Count;
        double[] colWidths = new double[colCount];
        double colWidth = width / colCount;

        for (int i = 0; i < colCount; i++)
        {
            colWidths[i] = colWidth;
        }

        // Draw header row
        double rowHeight = font.Height * 1.5;
        double cellPadding = 5;

        for (int i = 0; i < tableData.Count; i++)
        {
            var row = tableData[i];
            bool isHeader = i == 0;
            XFont currentFont = isHeader ? headerFont : font;

            // Draw cells
            double xPos = x;
            for (int j = 0; j < row.Cells.Count; j++)
            {
                // Draw cell text
                gfx.DrawString(row.Cells[j], currentFont, XBrushes.Black,
                    xPos + cellPadding, y + rowHeight - cellPadding);

                // Draw cell border
                gfx.DrawRectangle(XPens.Gray, xPos, y, colWidths[j], rowHeight);

                xPos += colWidths[j];
            }

            y += rowHeight;
        }

        return y;
    }

    private List<string> WrapText(string text, XFont font, double maxWidth, XGraphics gfx)
    {
        var result = new List<string>();
        if (string.IsNullOrEmpty(text))
            return result;

        var words = text.Split(' ');
        var currentLine = new StringBuilder();
        double currentWidth = 0;

        foreach (var word in words)
        {
            // Measure the word width using XGraphics
            double wordWidth = gfx.MeasureString(word + " ", font).Width;

            if (currentWidth + wordWidth > maxWidth)
            {
                if (currentLine.Length > 0)
                {
                    result.Add(currentLine.ToString().Trim());
                    currentLine.Clear();
                    currentWidth = 0;
                }
            }

            currentLine.Append(word + " ");
            currentWidth += wordWidth;
        }

        if (currentLine.Length > 0)
        {
            result.Add(currentLine.ToString().Trim());
        }

        return result;
    }

}

